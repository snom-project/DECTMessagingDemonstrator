# vi:si:et:sw=4:sts=4:ts=4
# -*- Mode: Python -*-
# -*- coding: utf-8 -*-
"""Trilateration.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19SxnPf7U_CkaIGPEwcqoCqcf7Noj-j1C
"""

import math
from math import pow
import numpy as np


n=2 # Environment
# Measured Power is also known as the 1 Meter RSSI.
MEASURED_POWER=-62 # M9B RX and M90 TX
def calc_rss(n,d,a):
    ''' Return distance in meter from rssi '''
    cal_rss= (-10*n*(math.log(d,10)))+a
    print(cal_rss)


def calc_dist(rss, n=2, measured_power=MEASURED_POWER):
    '''
      Formula Distance

      Measured Power: Measured Power is also known as the 1 Meter RSSI.
      RSSI
      N (Constant depends on the Environmental factor. Range 2-4)

      Distance = 10 ^ ((Measured Power â€“ RSSI)/(10 * N))
      use equivalent
      Distance = 10 ^ ((RSSI - Measured Power )/(-10 * N))
    '''
    cal_d= pow(10,((rss-measured_power)/(-10*n)))
    #print('distance in meters', pow(10,((rss-measured_power)/(-10*n))))
    return cal_d

def get_radii(rssi_1, rssi_2, rssi_3):
    ''' Return distances from 3 reference points lists 
    
        We only have one rssi value per device and M9B, therfor return rssi directly. 
    '''
    dist_arr_1=[]
    dist_arr_2=[]
    dist_arr_3=[]

    cal_d=calc_dist(rssi_1, n)
    dist_arr_1=np.append(dist_arr_1,cal_d)
    cal_d=calc_dist(rssi_2,n)
    dist_arr_2=np.append(dist_arr_2,cal_d)
    cal_d=calc_dist(rssi_3,n)
    dist_arr_3=np.append(dist_arr_3,cal_d)

    mean_1=np.nanmean(dist_arr_1)
    mean_2=np.nanmean(dist_arr_2)
    mean_3=np.nanmean(dist_arr_3)

    return mean_1, mean_2, mean_3

def trilateration(x1,y1,r1,x2,y2,r2,x3,y3,r3):
    ''' Return point x,y from trilateration of 3 reference points and their weights '''
    ''' All 3 reference points must be unique to form a triangle '''
    ''' If points are parallel or identical, NaN, NaN will be returned. '''
    A = 2*x2 - 2*x1
    B = 2*y2 - 2*y1
    C = r1**2 - r2**2 - x1**2 + x2**2 - y1**2 + y2**2
    D = 2*x3 - 2*x2
    E = 2*y3 - 2*y2
    F = r2**2 - r3**2 - x2**2 + x3**2 - y2**2 + y3**2
    x = (C*E - F*B) / (E*A - B*D)
    y = (C*D - A*F) / (B*D - A*E)
    return x,y

def calculateDistance(x1,y1,x2,y2):
    ''' Return distance of P1=(x1,y1) to P2=(x2,y2) '''
    dist = math.sqrt((x2 - x1)**2 + (y2 - y1)**2)
    return dist

if __name__ == "__main__":
    print(get_radii(-80.0, -80.0, -80.0))
    mean_1, mean_2, mean_3 = get_radii(-80.0, -80.0, -80.0)

    #x,y = trilateration(2,0,mean_1,1.5,1,mean_2,0,0,mean_3)
    x,y = trilateration(0,0,mean_1,5,0,mean_2,5,5,mean_3)

    print("distance between calculated and setup coordinates=", calculateDistance(1.5, 0, x, y) )

    print("calculated cordinates of tag (x,y)=",x,y) # -*- coding: utf-8 -*-


    import localization as lx

    P=lx.Project(mode='2D',solver='LSE')


    P.add_anchor('anchore_A',(0,0))
    #P.add_anchor('anchore_B',(100,100))
    P.add_anchor('anchore_C',(0,1000))

    t,label=P.add_target(ID="M90")
    print(t, label)

    t.add_measure('anchore_A',400)
    #t.add_measure('anchore_B',10)
    t.add_measure('anchore_C',601)

    P.solve()

    # Then the target location is:

    print(t.loc)
